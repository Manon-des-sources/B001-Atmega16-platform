
实现方式：<br>
1、引入事件序列的概念，一个任务(如读数据)必须在有限个序列内完成<br>
2、一个任务必须且只由事件序列来描述这个任务，也就是说任务函数是事件序列的直接排列<br>
3、每个序列只完成一个简单的子任务<br>
4、每个序列可以循环等待自己的子任务执行完毕，但不能是阻塞的<br>

参考实现：<br>
```java
// ==========================================================================================================
// 24C02操作状态机：
//
// 读操作一个状态函数列表
// 写操作一个状态函数列表
//
// 执行时只需要将状态函数列表遍历一遍即可
// 需要新的操作时、在建立一个对应的状态函数列表即可
//
// ==========================================================================================================
typedef struct
{
    uint8_t index;               // 状态函数遍历时使用
    uint8_t number;              // 状态函数列表的长度
    p_void_funtion_void p_list;  // 执行状态函数列表中的一个元素
} T_MOD_IIC_24C02;

// 读操作的状态函数列表
static p_void_funtion_void read_list[] =
{
    Drv_IIC_start,
    ...
    Drv_IIC_stop,
};

// 写操作的状态函数列表
static p_void_funtion_void write_list[] =
{
    Drv_IIC_start,
    ...
    Drv_IIC_stop,
};
```
