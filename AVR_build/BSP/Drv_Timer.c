// ==========================================================================================================
// Copyright (c) 2016 ChenChen <codingmanon@163.com>
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
// associated documentation files (the "Software"), to deal in the Software without restriction, including 
// without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
// sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject 
// to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in 
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// 
// --------------------------------------
// 本文定义了Atmega16定时器0/1/2 驱动模块
// 
// --------------------------------------
// 包含：
// 
// ==========================================================================================================
#include "Drv_Timer.h"


// ==========================================================================================================
// --------------------------------------
// 定时器0


// ==========================================================================================================
// TIMER0 初始化
// 
// 参数：wave_mode       工作模式/波形产生模式选择
//       OC_mode         比较匹配/PWM输出模式选择
//       clk_source      时钟源和预分频选择
// 
// 写TCCR0时需要清除bit7=FOC0
// 
// 定时器溢出周期 T = ((1.0 / 8000000) * 1000000) * clk_source * 256 ( @ 8MHz )
// ==========================================================================================================
void Drv_Timer0_init(const uint8_t wave_mode, const uint8_t com_mode, const uint8_t clk_source)
{
    uint8_t wgm00,wgm01;

    wgm00 =  wave_mode & 0x01;
    wgm01 = (wave_mode & 0x02) >> 1;

    // 写TCCR0时需要将bit7=FOC0清0
    TCCR0 = (wgm00 << 6)|               // 工作模式/波形产生模式选择
            (wgm01 << 3)|
            ((com_mode & 0x03)   << 4)| // 比较匹配/PWM输出模式选择
            ((clk_source & 0x07) << 0); // 时钟源和预分频选择
}

// ==========================================================================================================
// TIMER0 中断使能
// 
// 参数：int_mode  = INT_MODE_TOV 或 INT_MODE_OCF 或
//       enable    = ENABLE 或 DISABLE
// 
// 说明：
// (1). OC0引脚要先配置成比较匹配引脚、再修改数据方向寄存器DDB3
// (2). 可以单独使能/禁止一种模式的中断
// 
// ==========================================================================================================
void Drv_Timer0_INT_Enable(const uint8_t int_mode, const uint8_t enable)
{
    if(INT_MODE_TOV == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << TOIE0);
        }
        else
        {
            TIMSK |=  (1 << TOIE0);
        }
        TIFR |= (1 << TOV0);
    }
    if(INT_MODE_OCF == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << OCIE0);
        }
        else
        {
            TIMSK |=  (1 << OCIE0);
        }
        TIFR |= (1 << OCF0);
    }
}

// ==========================================================================================================
//      设置TCNT0和OCR0的值
// 
// (1). 在比较匹配下、OCR0需要在TCNT0被设置之后设置
// ==========================================================================================================
void Drv_Timer0_set_TCNT0_OCR0(const uint8_t tcnt0, const uint8_t ocr0)
{
    TCNT0 = tcnt0;
    OCR0  = ocr0;
}

// ==========================================================================================================
// TIMER0 溢出中断服务程序
// 
// ==========================================================================================================
ISR(TIMER0_OVF_vect)
{
}

// 
// ----------------------------------------------------------------------------------------------------------
// 在sys_timer.c中被使用来调度各个任务
//
// ==========================================================================================================
// TIMER0 比较匹配中断服务程序
// 
// ==========================================================================================================
// ISR(TIMER0_COMP_vect)
// {
// }
//



// ==========================================================================================================
// --------------------------------------
// 定时器1


// ==========================================================================================================
// 定时器1初始化
// 
// 参数：OCM1A_mode      通道A比较匹配/PWM输出模式选择
//       OCM1B_mode      通道B比较匹配/PWM输出模式选择
//       com_mode        工作模式/波形产生模式选择
//       clk_source      时钟源和预分频选择
// 
// PWM模式下、写TCCR1A时需要清除FOC1A/B
// 写TCCR1B时需要清除bit5
// 
// ==========================================================================================================
void Drv_Timer1_init(const uint8_t com_mode, const uint8_t OCM1A_mode, const uint8_t OCM1B_mode, const uint8_t clk_source)
{
    TCCR1A = ((OCM1A_mode & 0x03) << 6) |   // 通道A比较匹配/PWM输出模式选择
             ((OCM1B_mode & 0x03) << 4) |   // 通道B比较匹配/PWM输出模式选择
             ((com_mode   & 0x03) << 0);    // 工作模式/波形产生模式选择(WGM[11:10])

    TCCR1B = (((com_mode & 0x0C) >> 2) << 3)   |    // 工作模式/波形产生模式选择(WGM[13:12])
             ( (clk_source & 0x07)     << 0);       // 时钟源和预分频选择
}

// ==========================================================================================================
// 定时器1初始化为ICP功能
// 
// 参数：flit_enable    输入捕捉噪声抑制功能使能
//       edge           输入捕捉边沿选择
// 
// 参数可选选项(TIMER1_ICP)：
//     ENABLE  = 1
//     DISABLE = 0
//     ICP_FALL_EDGE    = 0,
//     ICP_RAISE_EDGE   = 1
// 
// 写TCCR1B时需要清除bit5
// 
// ==========================================================================================================
void Drv_Timer1_init_for_ICP(const uint8_t flit_enable, const uint8_t edge)
{
    TCCR1B = ((flit_enable & 0x01) << 7)    |   // 输入捕捉噪声抑制功能使能
             ((edge        & 0x01) << 6);       // 输入捕捉边沿选择
}


// ==========================================================================================================
// TIMER1 中断使能
// 
// 参数：int_mode = INT_MODE_TOV 或 INT_MODE_ICF 或 INT_MODE_OCF1A  或 INT_MODE_OCF1B
//       enable   = ENABLE 或 DISABLE
// 
// 说明：
// (1). OC1A/OC1B引脚要先配置成比较匹配引脚、再修改数据方向寄存器DDD5/DDD4
// (2). 可以单独使能/禁止一种模式的中断
// 
// ==========================================================================================================
void Drv_Timer1_INT_Enable(const uint8_t int_mode, const uint8_t enable)
{
    if(INT_MODE_TOV == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << TOIE1);
        }
        else
        {
            TIMSK |=  (1 << TOIE1);
        }
        TIFR |= (1 << TOV1);
        goto out;
    }
    if(INT_MODE_OCF1A == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << OCIE1A);
        }
        else
        {
            TIMSK |=  (1 << OCIE1A);
        }
        TIFR |= (1 << OCF1A);
        goto out;
    }
    if(INT_MODE_OCF1B == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << OCIE1B);
        }
        else
        {
            TIMSK |=  (1 << OCIE1B);
        }
        TIFR |= (1 << OCF1B);
        goto out;
    }
    if(INT_MODE_ICF == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << TICIE1);
        }
        else
        {
            TIMSK |=  (1 << TICIE1);
        }
        TIFR |= (1 << ICF1);
    }

out:
    return ;
}

// ==========================================================================================================
//      设置TCNT1、OCR1A、OCR1B的值
// 
// (1). 在比较匹配下、OCR1A、OCR1B需要在TCNT1被设置之后设置
//      相应的，ICP1也需要在TCNT1被设置之后设置
// 
// ==========================================================================================================
void Drv_Timer1_set_TCNT1_OCR1A_OCR1B_ICR1(const uint16_t tcnt1, const uint16_t ocr1a, const uint16_t ocr1b, const uint16_t icr1)
{
    TCNT1 = tcnt1;
    OCR1A = ocr1a;
    OCR1B = ocr1b;
    ICR1  = icr1;
}

// ==========================================================================================================
// TIMER1 溢出中断服务程序
// 
// ==========================================================================================================
ISR(TIMER1_OVF_vect)
{
}

// ==========================================================================================================
// TIMER1 比较匹配A 中断服务程序
// 
// ==========================================================================================================
ISR(TIMER1_COMPA_vect)
{
}

// ==========================================================================================================
// TIMER1 比较匹配B 中断服务程序
// 
// ==========================================================================================================
ISR(TIMER1_COMPB_vect)
{
}

// ==========================================================================================================
// TIMER1 输入捕捉 中断服务程序
// 
// ==========================================================================================================
ISR(TIMER1_CAPT_vect)
{
}






// ==========================================================================================================
// --------------------------------------
// 定时器2/TIMER2


// ==========================================================================================================
// TIMER2 初始化
// 
// 参数：wave_mode       工作模式/波形产生模式选择
//       OC_mode         比较匹配/PWM输出模式选择
//       clk_source      时钟源和预分频选择
// 
// 写TCCR2时需要清除bit7=FOC2
// 
// 定时器溢出周期 T = ((1.0 / 8000000) * 1000000) * clk_source * 256 ( @ 8MHz )
// ==========================================================================================================
void Drv_Timer2_init(const uint8_t wave_mode, const uint8_t com_mode, const uint8_t clk_source)
{
    uint8_t wgm20,wgm21;

    wgm20 =  wave_mode & 0x01;
    wgm21 = (wave_mode & 0x02) >> 1;

    // 写TCCR2时需要将bit7=FOC2清0
    TCCR2 = (wgm20 << 6)|               // 工作模式/波形产生模式选择
            (wgm21 << 3)|
            ((com_mode & 0x03)   << 4)| // 比较匹配/PWM输出模式选择
            ((clk_source & 0x07) << 0); // 时钟源和预分频选择
}

// ==========================================================================================================
// TIMER2 中断使能
// 
// 参数：int_mode = INT_MODE_TOV 或 INT_MODE_OCF
//       enable   = ENABLE 或 DISABLE
// 
// 说明：
// (1). OC2引脚要先配置成比较匹配引脚、再修改数据方向寄存器DDD7
// (2). 可以单独使能/禁止一种模式的中断
// 
// ==========================================================================================================
void Drv_Timer2_INT_Enable(const uint8_t int_mode, const uint8_t enable)
{
    if(INT_MODE_TOV == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << TOIE2);
        }
        else
        {
            TIMSK |=  (1 << TOIE2);
        }
        TIFR |= (1 << TOV2);
    }
    if(INT_MODE_OCF == int_mode)
    {
        if(DISABLE == enable)
        {
            TIMSK &= ~(1 << OCIE2);
        }
        else
        {
            TIMSK |=  (1 << OCIE2);
        }
        TIFR |= (1 << OCF2);
    }
}

// ==========================================================================================================
//      设置TCNT2和OCR2的值
// 
// (1). 在比较匹配下、OCR2需要在TCNT2被设置之后设置
// ==========================================================================================================
void Drv_Timer2_set_TCNT2_OCR2(const uint8_t tcnt2, const uint8_t ocr2)
{
    TCNT2 = tcnt2;
    OCR2  = ocr2;
}

// ==========================================================================================================
//      强制触发一次比较匹配
// 
// (1). FOC2写1后、立即进行比较操作
// ==========================================================================================================
void Drv_Timer2_FOC2_enable(const uint8_t enable)
{
    if(DISABLE == enable)
    {
        TCCR2 |=  (1 << FOC2);
    }
    else
    {
        TCCR2 &= ~(1 << FOC2);
    }
}

// ==========================================================================================================
// TIMER2 溢出中断服务程序
// 
// ==========================================================================================================
ISR(TIMER2_OVF_vect)
{
}

// ==========================================================================================================
// TIMER2 比较匹配中断服务程序
// 
// ==========================================================================================================
ISR(TIMER2_COMP_vect)
{
}












